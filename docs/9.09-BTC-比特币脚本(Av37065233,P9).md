**9.09-BTC-比特币脚本(Av37065233,P9)**

今天我们讲一下比特币交易里使用的脚本语言。这是比特币的一个交易实例。这个交易有一个输入，两个输出。左边这个地方写的是output，其实是这个交易的输入。它的意思是说这个输入中使用的B是来自前面哪个交易的输出。右边的两个output中，下面那个已经划出去了，上面那个还没划出去。这个交易已经受到了23个确认，所以回滚的可能性很小了。

下面是这个交易的输入和输出脚本。输入脚本包含两个操作，分别把两个很长的数压入栈里。比特币使用的脚本语言是非常简单的，唯一能访问的内存空间就是一个堆栈，不像通用的编程语言，像CC加加那样有全局变量、局部变量，还有什么动态分配的内存空间。它这里就是一个栈，所以叫做基于栈的语言stock
based
language。这里的输出脚本有两行，分别对应上面的两个输出，每个输出有自己单独的一段脚本。

下面我们看一下这个交易的具体内容。首先看一下这个交易的一些宏观信息，就所谓的叫meta
data。包括这第一行的transaction
ID然后第二行的hash这个交易的哈希值，然后接下来是version使用的比特币协议的版本号size是这个交易的大小。这个knock
time的话我们以前没有接触过，knock
time是指用来设定交易的生效时间，但这里写的是零，表示立即生效。就绝大多数情况下这个lock
time都是0。如果是非零值的话，那么这个交易要过一段时间才能生效。比如说要等十个区块以后才能够被写入区块链里。有一些比较特殊的transaction会用到这些motime
feature。

下面这个we in和v
out是输入输出部分，我们后面会详细讲。就在这个ppt上我们没有把它展开写block
cash是这个交易所在的区块的哈希值。我们可以看到这个哈希值也是有一长串的零开头就是挖矿要求的这个难度要求都是这样。

Confirmation是这个交易已经有多少个确认信息。就像我们前面一页看到的，这个交易是有23个确认信息。Time是这个交易产生的时间，block
time是这个区块产生的时间。这两个时间就这个time和block
time都是表示成从某个很早的时间点到现在过了多少秒。

这是交易的输入结构，是个数主，一个交易可以有多个输入。我们这个例子当中它只有一个输入，每个输入都要说明这个输入花的币是来自之前哪个交易的输出。所以他这个前两行就是给出输出这个B的来源。第一个传达声ID就是之前这个交易的哈希值，we
out表示是这个交易里的第几个输出。这大家听明白了吗？就这个例子当中，他就是说花的这个币就是来自于这个哈希值，就是这个C0CB开头的这个交易中。

第零个输出，接下来就是输入脚本，这个输入脚本叫做script。因为输入脚本最简单的形式就是给出一个sig就。行了，证明你有权利花这个钱。我们后面的这个ppt当中，这个script我们就直接写成input
script，有输入脚本。

如果一个交易有多个输入的话，每个输入都要说明D的来源，并且要给出签名。也就是说比特币中的一个交易可能需要多个千名。这是交易的输出，也是一个数主结构。

我们这个例子当中是有两个输出，这个value是输出的金额，就是给对方转过去多少钱。这里的单位是比特币，所以他这里是0.22684个比特币，也有的地方是表示成Seto就，to就是叫异葱。比特币里的最小单位satoshe这个单位是很小的，所以如果表示成satoa的话，转账的金额看上去都是很大的。像这个例子当中，如果我们把它表示成Seto的话，就是22684000葱，这个N是序号表示，这是这个交易里的第几个输出这个script
pup key就是输出脚本，就是我们后面都写成output
script。那为什么它这里叫script
pukey？因为输出脚本最简单的形式就是给出一个public
key，下面这个asm显示的是输出脚本的内容，里面包含一系列的操作。这个我们后面会详细解释它这个操作是什么意思。

Request这个是说这个输出需要多少个签名才能兑现。这两个例子当中，都是只需要一个签名就够了。我们后面会讲到multi
se就是多重签名，有的输出要多个签名才行。这个type是输出的类型，这两个类型都是public
key，hash是公钥的哈希，address是输出的地址。

下面我们看一下这些输入和输入脚本是怎么执行的。上面我们画的是一个小型的区块链，在前面这个区块里有一个A给B的转账交易，A转给了B那币收到这个转过来的币之后，在后面这个区块里就隔了两个区块里把这些币又转给了C也就是说我们这个例子当中，B给C的这个交易中，B的来源是来自于前面A转给B的这个交易。所以下面这个内容里我们就可以看到B转给C的这个交易的输入里。这个transaction
ID和v out指向的是A转给B的这个交易的输出。

要验证这个交易的合法性，是要把B转给C的个个交易的输入脚本跟A转给B的这个交易的输出脚本拼接在一起来执行的。注意这里有个交叉，前面这个交易的输出脚本放在后面，后面这个交易的输入脚本放在前面。在早期的比特币实现中，这两个脚本是拼接在一起，从头到尾执行一遍。后来出于安全因素的考虑，这两个脚本改为分别执行。首先执行输入脚本如果没有出错，那么在执行输出脚本如果能顺利执行，最后占顶的结果为非零值，也就是处那么验证通过这个交易就是合法的。如果执行过程中出现任何错误，这个交易就是非法的。如果一个交易有多个输入的话，那么每个输入脚本都要和所对应的交易的输出脚本匹配之后来进行验证，全都验证通过这个交易才是合法的。

我们来看看输入输出脚本的几种形式。一种最简单的形式就是pay to public
key，输出脚本里直接给出收款人的公钥。第二行的这个check
si是检查签名的操作，在输入脚本里直接给出签名就行了。这个签名是用私钥对这个输入脚本所在的整个交易的签名。这种形式是最简单的，因为public
key是直接在输出脚本里给出的。

我们看一下实际执行情况，这三行是把输入脚本和输出脚本拼接起来之后的结果。第一行来自输入脚本，后两行来自输出脚本。注意就像刚才说的，实际代码中出于安全考虑，这两段胶本实际上是分别执行的。我们这个ppt里面为了方便起见，就把这两段脚本拼接在一起显示，然后从上往下一条一条语句来执行。第一条语句把输入脚本里提供的签名压入站。第二条是把输出里提供的公钥压入栈。第三条这个check它的作用是把栈顶的这两个元素弹出来，用公钥检查一下这个签名是否正确。如果正确的话，返回处说明验证通过，否则的话执行出错，这个交易就是非法的。

这是pay to public
key的一个实例。上面这个交易的输入脚本就是把签名压入站，那就一行就压入这个签名。下面这个交易是上面这个输入的B的来源，它的输出有两行，第一行是把公钥压入站，第二行就是check
save。这是第一种形式。下面我们看一下第二种形式，pay to public key hash.

这种形式与刚才讲的那种形式的区别在于，输出脚本里没有直接给出收款人的公钥，给出的是公钥的哈希公钥是在输入脚本里给出的。输入脚本既要给出签名，也要给出公要输出脚本里其他还有一些操作，像一开始的du呀，然后第二行的H是160，这些操作都是为了验证这个签名的正确性，这种形式实际上是最常用的。就这个pay
to public key hash是最常用的一种形式。

下面我们看一下这个脚本执行起来的结果。这个是把上一页的输入脚本和输出脚本拼接之后，得到了前两条语句来自输入脚本，后面的语句来自输出脚本，还是从上往下执行。第一条语句先把签名压入战，第二条语句把公要押入站。第三条语句，这个du它的含义是把栈顶的元素复制一遍，所以栈顶又多了一个公要。下一条语句H160是把这个栈点元素弹出来取哈希，然后把得到的哈希值再压入站，所以占顶变成了公钥的哈希值。下面一条语句是把输出脚本里提供的公钥的哈希值压入栈，这个时候栈顶有两个哈希值，大家注意搞清楚，他们是怎么来的。

上面这个哈希值是输出脚本里面提供的收款人的公钥的哈希。就是我发布这个交易的时候，我这个转账的钱要转给谁的。在输出脚本里提供一个收款人的公要的哈希。下面这个哈希值，是你要花这个钱的时候，在输入脚本里给出的公钥。然后前面那个操作，这是160操作取哈希后得到的。

那么再下面这个equal
verify这个操作的作用是弹出栈顶的两个元素比较它们是否相等，就比较这个栈顶的两个哈希值是否相等。这样做的目的是什么？我们前面课上讲过，防止有人冒名顶替，用他自己的公钥冒充收款人的公钥。假设这两个哈希值是相等的，那么就从占顶消失了。

最后一条这个check我们前面已经讲过了，弹出栈顶的两个元素，用公钥检查这个枪名是否正确。假设这个签名是正确的，那么整个脚本顺利运行结束，栈顶留下的是处。如果执行过程中任何一个环节发生错误。比如输入里给出的公钥跟输出里给出的哈希值对不上，或者是输入里给出的签名跟给出的公钥对不上，那么这个交易就是非法的。

Pay to public key
hash是最常用的脚本形式。我们这个ppt第一页显示的那个实例用的就是这种形式的脚本。现在我们应该能够看懂了。这个input
script output
script这个输入脚本就是把签名押入站，把公钥押入站。下面这个输出脚本复制栈顶元素，这个du然后取哈希值还160。第三个是把公钥的哈希压入站，最后依尔比较占顶的两个哈希值，然后check
si检查签名。

最后一种也是最复杂的一种脚本形式是pay to script
hash这种形式的输出。脚本给出的不是收款人的公钥的哈希，而是收款人提供的一个脚本的哈希。这个脚本叫redeem
script赎回脚本。将来花这个钱的时候，输入脚本里要给出这个redeem
script，这个赎回脚本的具体内容。同时还要给出让这个赎回脚本能够正确运行所需要的签名。

验证的时候分为两步。第一步验证输入脚本里给出的这个赎回脚本是不是跟输出脚本里给出的哈希值匹配。如果不匹配的话，那么说明给出的赎回脚本是不对的，就类似于刚才讲的那种pay
to public key
hash里面给出的公钥不对一样。这个地方如果这个跟哈希值匹配不上，说明你给出的赎回脚本是不对的，那么验证就失败了。如果输入里给出的赎回脚本是正确的，那么第二步还要把这个赎回脚本的内容当做操作指令来执行一遍，看看最后能不能顺利执行。如果两部验证都通过了，那么这个交易才是合法的。

这个听上去好像有点抽象，我们下面看一个具体的例子，用pay to script
hash实现我们前面说的pay to public
key的功能。这里的输入脚本就是给出签名，再给出序列化的赎回脚本。赎回脚本的内容就是给出公钥，然后用这个check
see检查签名。

下面这个输出脚本是用来验证输入脚本里给出的赎回脚本是否正确。我们看一下这个pay
to script
hash的执行过程。开始的时候也是把输入脚本和输出脚本拼接在一起。前两行来自输入脚本，后面三行来自输出脚本。

首先把输入脚本的sig车压入栈。然后把赎回脚本压入栈。然后是这个取哈希的操作，得到赎回脚本的哈希。这个rsh是指redeem
script
hash赎回脚本的哈希值。接下来还要把输出脚本里给出的这哈希值压入栈，这个时候这个栈里就有两个哈希值了，最后用1比较一下这两个哈希值是否相等，如果不等的话，那就game
over了。假设这两个相等，那这两个哈希值就从占顶消失了。

到这里，第一阶段的验证就算结束了，接下来还要进行第二个阶段的验证。第二个阶段首先要把输入脚本里提供的序列化的赎回脚本进行反序列化。这个反序列化的操作在这个ppt上并没有展现出来，即使每个节点自己要完成了。然后执行这个赎回脚本，首先把这个public
p压入站。然后用这个check
sig验证一下，输入脚本里给出的这个signature的正确性验证通过之后，整个pay
to script hash才算执行完成。

看到这里同学们可能会有一个疑问，搞这么复杂干嘛？就用前面讲过的pay to
public
key不就行了吗？为什么一定要把这部分功能嵌入到赎回脚本里面？确实对这个简单的例子来说，这么搞是有点复杂了。

配to script
hash这个功能在最初版本的比特币里面是没有的，后来通过软分叉的形式加进去了。它的一个常见的应用场景就是对多重签名的支持。比特币系统中一个输出可能要求多个签名才能把钱取出来。比如某个公司的账户可能要求五个合伙人中任意三个人的签名才能把这个公司账户上的钱取走。这样为私钥的泄露提供了一些安全的保护。比如说有某个合伙人私钥泄露出去了，那么问题也不大，因为还需要另外两个人的签名才能把钱取出来。同时他也为私钥的丢失提供了一些冗余，就五个合伙人中即使有两个人把四要给忘掉了。剩下三个人仍然可以把钱取出来，然后转到某一个安全的账户。

这个功能是通过check mulsigg来实现的。就是这一页最后一行这个check
mulseg操作，输出脚本里给出N个公要，同时指定一个阈值M输入脚本只要提供这N个公要对应的签名中任意M个合法的签名就能通过验证。比如刚才举的那个例子当中，N
等于5，M 等于35个合伙人中任意三个人的签名都可以。

输入脚本的第一行有一个红色的叉子，它这个是情况是这样的，比特币中check
multi的实现有一个bug，执行的时候会从堆栈上多弹出一个元素，这个就是它代码实现的一个bug。这个bug现在已经没有办法改了，因为这是个去中性化的系统。你要想通过软件升级的方法去修复这个bug，这个代价是很大的。要改的话需要硬分叉，所以实际采用的解决方案是在输入脚本里往站上多压进去，一个没用的元素。第一行我们写的这个红色的叉子就是代表这个多余的元素。为了迁就这个check
multise实现上的bug往堆阵上多压进去的元素。

另外注意给出的这M个签名的相对顺序，要跟他们在N个公钥中的相对顺序是一致的才行。这是check
mulse的执行过程。这个例子中假设三个签名中给出两个就行，那大家可以看到这两个签名给出的相对顺序也是跟他们在公钥中的顺序是一样的。

在公钥当中，第一个公要排在第二个公钥的前面。那么相对应的签名，给出这两个签名的时候，也是第一个签名排在第二个签名的签名。这个第一行的force就是我们前面说的那个多余的元素。首先把这个多余的元素压入栈里，然后把这两个签名依次压入栈。这个时候输入脚本就执行完了。接下来的输出脚本里把M的值这个阈值M压入栈，然后把三个公要押入栈。然后把N的值加入栈，最后就执行check，看看这个堆栈里是不是包含了这三个签名中的两个。如果是的话，那么验证通过。

大家看看有什么问题吗？

注意这个过程当中并没有用到pay to script，就是用比特币脚本中原生的check
mulse来实现的。这么实现有什么问题吗？

早期的多重签名就是这样实现的。在实际应用当中有一些不是很方便的地方。比如网上购物，某个电商用毛充签名，那么要求五个合伙人中任意三个人的签名才能把钱取出来。这就要求用户网上购物的用户在支付的时候生成的转账交易里给出这五个合伙人的公钥，同时还要给出N和M的值。像这个例子当中要写明N
等于5，M
等于3。这些都是用户在网上购物的时候生成转账交易时，输出脚本里要给出的信息。给出这五个公要给出N和M是多少。用户怎么知道这些信息呢？需要这个购物网站在他的网上公布出来，所以这个网上可以公布。

我们用了多重签名，我们用了五个签名中要给出三个，这是五个公钥。然后用户生成这个转账交易的时候，又把这些信息填进去。那么不同的电商，它采用的多重签名的规则是不一样的。就有的电商可能是五个签名中任意三个，有的可能要求五个签名中你要给出四个，也有可能电商要求六个签名当中你要给出三个，这都是有可能的这就给用户生成转账交易带来了一些不方便的地方。因为这些复杂性都暴露给用户了，那么怎么办呢？这就要用到pay
to script hash。

这是用pay to script
hash实现的多重签名。它的本质是把复杂度从输出脚本转移到了输入脚本。现在这个输出脚本变得非常简单，只有这三行原来的复杂度被转移到了这个redeem
script赎回脚本里面。输出脚本只要给出这个赎回脚本的哈希值就行了，这个赎回脚本里要给出这N个公钥，还有N和M的值。

这个赎回脚本是在输入脚本里提供的，也就是说是由收款人提供的，大家明白这样做的用意了吗？像前面那个网上购物的例子，收款人是电商，他只要在网站上公布这个赎回脚本的哈希值，然后用户生成转账交易的时候，把这个哈希值包含在输出脚本里就行了。至于这个电商用什么样的多重签名规则，是五个里选三个还是三个里选两个，对于用户来说是不可见的，用户没必要知道。从用户的角度来看，采用这种支付方式跟采用前面说的pay
to public key
hash没有多大区别，只不过把公钥的哈希纸换成了赎回脚本的哈希值。当然了，输出脚本的写法上也有一些区别，但不是本质性的。

这个输入脚本是电商在花掉这笔输出的时候提供的，其中包含这个赎回脚本的序列化版本，同时还包含让这个赎回脚本验证通过所需的M个签名。将来如果这个电商改变了所采用的多重签名规则，比如原来是五个里选三个，现在变成三个律选两个。那么只要改变这个输入脚本和赎回脚本的内容，然后把新的哈希值公布出去就行了。对用户来说，只不过是付款的时候要包含的这个哈希值发生了变化，其他的变化没有必要知道。

我们看一下具体的执行过程，即是把输入脚本和输出脚本拼接在一起后的情况。第一行的这个force就是为了应付check
multiseg那个bug而准备的一个没用的元素。执行的时候先把它押入站。然后依次把两个签名押入站。接下来是这个序列化的赎回脚本，目前只是把它作为数据压入这。

到这里输入脚本就执行完了，下面是输出脚本取哈西。然后把输出脚本里提供的这个哈希值压入栈顶。最后判断一下这两个哈希值是否相等。到这里，第一阶段的验证就完成了。

下面开始第二个阶段的验证，把赎回脚本展开后执行，先把M压入栈。然后把三个公要押入战。把N压入栈，最后检查一下多重签名的正确性，三个里面有两个是正确的。第二阶段的验证过程跟前面直接使用check
mulse的情况是类似的。

这是网上使用pay to script
hash来做多重签名的一个实例。上面输入脚本的最后一个就是序列化的赎回脚本。反序列化之后得到的就是三个里面取两个的多重签名脚本。下面这个输出脚本的内容跟我们前面讲的是一样的。现在的多重签名一般都是采用这种pay
to script hash的形式。

最后我们要讲的这种脚本格式是比较特殊的。这种格式的输出脚本开头是return这个操作，后面可以跟任意的内容return。这个操作的作用是无条件的返回错误，所以包含这个操作的脚本永远不可能通过验证执行到这个return语句就会出错，然后执行就终止了。后面跟的内容根本没有机会执行。

同学们听到这里可能觉得很奇怪，为什么要设计这样的输出脚本？这样的输出岂不是永远花不出去吗？你不论输入脚本写的是什么内容，执行到输出的这个return语句他就报错了。那么这里的钱永远都花不出去，确实是这样的。这个脚本是证明销毁比特币的一种方法。那么为什么要销毁比特币呢？比特币现在这么值钱，你这么销毁掉岂不是非常可惜？这个一般是有两种应用场景，一种场景是有些小的币种要求销毁一定数量的比特币才能够得到这个币种。有时候我们管这种小币种叫autocoin。

就是alternative core。

除了比特币之外的其他小的加密货币，你都可以认为叫。比如有的小币种可能要求你销毁一个比特币，可以得到1000个这样的小币。也就是说你要用这种方法证明你付出了一定的代价，才能够得到这个小币种。

另外一个应用场景是往区块链里写入一些内容。我们说区块链是个不可篡改的账本，有人就利用这个特性往里面添加一些需要永久保存在内容。比如说我们第一节课讲的一个场景是digital
commitment。

你要证明在某个时间知道某些事情，比如说涉及到知识产权保护的。把某项知识产权的内容取哈希之后，把哈希值放在这个return语句的后面。这后面的内容反正是永远不会执行的，你往里写什么都没关系。而且你放在这里的是一个哈希值，你有什么知识产权，取个哈希之后，把哈希值放在这，这个不会占太大的地方，而且也没有泄露出来你知识产权的具体内容。将来如果出现了纠纷，像知识产权的一些专利诉讼。你再把这个具体内容公布出去，就这个哈希值的当初的输入公布出去，证明你在某个时间点已经知道某个知识了。

同学们有没有觉得这个应用场景听起来比较耳熟？我们以前课上讲其他某个地方的时候，也讲到类似的应用场景。就是那个con
base域对吧？我们讲。

Columbase transaction里面有一个con
base域，你在这个域里写什么内容同样是没人管的，所以为什么不用这种方法？这个还不用销毁比特币了，就可以直接往里写。

这种方法只有获得记账权的那个节点才能用。如果你是一个全节点，你挖矿挖到了，然后你发布一个区块，可以往这个call
base transaction里的call
base域写入一些内容，这是可以的。而我们说的这种方法，是所有的节点都可以用的。甚至你不一定是个节点，可能就是一个普通的比特币上的用户，任何人都可以用这种方法去写入一些内容。大家听明白了吗？发布交易不需要有记账权，发布区块才需要有记账权。任何用户都可以用这种方法销毁很少一点比特币。比如说0.00一个比特币，换取往这个区块链里面写入一些内容的机会。我们接下来会看一些例子，有些交易其实根本就没有销毁比特币，只不过支付了交易费。我们下面看两个实例。

这是个column base
transaction。这个交易有两个输出。第一个输出的脚本是正常的pay to public
key hash，输出的金额就是得到的block
reward加上transaction费。第二个输出的金额是0，输出脚本就是刚才说的那种格式，开头是return，后面跟了一些乱七八糟的内容。第二个输出的目的就是为了往区块链里写一些东西。

这是个普通的转账交易，输出脚本也是以return开头的。这个交易的输入是0.05个比特币，输出金额是0，说明输入金额全部用来支付交易费了。这个交易其实并没有销毁任何比特币，只不过把输入里的比特币作为交易费转给这个挖到矿的矿工了。

这种形式的脚本的一个好处是，矿工看到这种脚本的时候，知道它里面的输出永远不可能兑现，所以就没有必要把它保存在ut
XO里面，这样对全节点是比较友好的。大家有什么问题吗？就有一点说明一下，我们这个ppt当中涉及到的比特币脚本的操作，为了简单起见都没有加上up前缀。就比如说我们前面写的。Check
si实际上应该是op check th那么？Check multiti th也是op check，还有。

这个deal.

应该也叫做up
deal。我们这个ppt简单起见就没有把它写上去。最后总结一下，比特币系统当中用的这个脚本语言是非常简单的，甚至连专门的名字都没有，他就叫比特币脚本语言bitcoin
scripting
language。我们后面可以看到像以太坊当中用的智能合约的语言，就这就比这个要复杂的多。比如说比特币的脚本语言不支持循环，所以有很多功能这个语言是实现不了的，这样的设计是有其用意的，不支持循环就不会有死循环，就不用担心停机问题。大家听说过吧hoting
problem。像以太坊当中，它的智能合约的语言是图灵完备的，表达能力很强。所以就要需要靠汽油费的机制来防止这个程序陷入死循环。

另外一方面，我们注意这个语言虽然在某些方面功能是很有限的，但是在另外一些方面它的功能却很强大，就是跟密码学相关的功能是很强大的。比如说这个check
multi检查多重签名，用一条语句就能够完成，这个比很多通用的编程语言要方便的多。所以比特币的脚本语言虽然看上去很简单，但其实针对比特币的应用场景做了很好的优化。还有问题吗？我们这节课就上到这。
