**17.17-ETH-交易树和收据树(Av37065233,P17)**

我们上节课讲了以太坊中的状态树，以太坊中还有另外两棵树，交易数和收据数。每次发布一个区块的时候，这个区块里所包含的那些交易会组织成一棵交易树，也是一颗莫扣吹跟比特币中的情况是类似的。同时以太坊还增加了一个收据数，每个交易执行完之后会形成一个收据记录。这个交易的相关信息就是交易数跟收据数上面的节点是一一对应的。增加这个收据数主要是考虑到以太坊的智能合约执行过程比较复杂。所以通过增加这个收据数的结构，有利于我们快速查询一些执行的结果。从数据结构上，交易数和收据数都是MPT，就我们上节课讲的。

这个数据结构跟比特币有所区别。比特币中的交易数就是用普通的motree，就区块里的所有交易就组织成一个普通的motree。当然你mp
t也是一种摸扣吹，这个叫morcal portratree，它也是一种morcal
tree。但是跟比特币中用的不是完全一样，为什么有这个区别呢？我猜其实就是为了方便以太坊中的三棵树都用同样的数据结构，这样代码比较统一，便于管理，不一定非要有什么更深层次的原因。

当然了，用mpt的一个好处是它支持查找操作，就是你可以通过键值重顶向下沿着这个数进行查找。对于状态数来说，查找的键值就是这个账户的地址。对于交易书和收据书来说，查找的间值就是这个交易在发布的区块里面的序号，就它排第几这个交易的排列顺序是由发布区块的那个节点决定的。

这三棵树有一个比较重要的区别，就是交易数和收据数都是只把当前发布的这个区块的交易组织起来的。而状态数是把系统中所有账户的状态都要包含进去，不管这些账户跟当前区块的交易有没有什么关系。从这个数据结构上来说，我们上节课讲过多个区块的状态数是共享节点的。所每次新发布一个区块的时候，只有这个区块中的交易影响了，就改变了状态的那些节点需要新建一个分支，其他的节点都是沿用原来种在树上的节点就行了。相比之下，交易数和收据数，每个区块的交易数和收据数都是独立的，他们是不会共享节点，就一个区块跟另外一个区块发布的交易本身我们也认为是独立。

那么交易书和收据书有什么用呢？一个用途就是提供moproof，就像比特币当中交易术，可以用来证明某个交易被打包到某个区块里面了，就可以向清洁点提供这样的模科普。收据数也是类似的，你要证明某个交易的执行结果，也可以在收据书里面提供一个moproof。

除此之外，以太坊还支持一些更加复杂的查询操作。比如说你想找到过去十天当中所有跟某个智能合约有关的交易，那这个应该怎么查呢？一种方法是把过去十天产生的所有区块都扫描一遍，看看其中有哪些交易是跟这个智能合约相关的。但这种方法它的复杂度就比较高，而且你对于清洁点来说，实际上清洁点没有交易列表，它只有一个块头的信息。所以他也没有办法通过扫描所有交易列表的方法来找到符合这种查询条件的交易。

与之类似的一些查询。比如说找到过去十天当中符合某种类型的所有事件。比如说所有的众筹事件，或者是所有的发行星币的事件。这些都是需要一个比较高效的方法才能支持，怎么办呢？以太坊中引入了filter这个数据结构。

大家以前学过blue filter吗？

不论filter这个数据结构可以支持比较高效的查找某个元素是不是在一个比较大的集合里面。比如说你有一个集合里面有很多元素，那么现在你想知道某个指定的元素是不是在这个集合里怎么办？大家能想到什么样的查询方法？

一个最笨的方法是什么？我把这个集合中的元素编历一遍，看看有没有我想找的那个元素。这个的复杂度是线性的对吧？是C塔N的复杂度。另外再有一个前提是什么？你得有足够的存储来保存整个集合的元素。对于清洁点来说，它其实没有这个交易列表，它没有整个集合的元素信息，所以这种方法它是用不了的那怎么办呢？

Blue
filter用一个很巧妙的思想给这个大的集合包含很多元素的集合，计算出一个很紧凑的摘要。比如说一个128倍的向量。比如我们这个例子当中，假设有一个集合ABC这是个集合，我们要给它计算出一个digest。

底下是一个。

向量。

这个向量初始的时候都是零，然后我们有一个哈希函数H它把每一个元素映射到向量中的某个位置。比如说A这个元素取哈希之后映射到这个位置，然后我就把这个位置的元素从零变成一。然后B可能映射到这个位置，那么这个地方也支成一。C,
比如C映射到这个。

位置。

变成一。就是把每一个元素都取哈希，找到向量中的对应位置，然后把它制成一，所有的元素都处理完了，得到这个向量，就是原来集合的一个摘要。这个摘要比原来的集合要小很多，就我们这个例子当中，比如说你就用一个128个就可以代表了这个摘要有什么用呢？

比如说我们有一个元素叫D我们想知道D这个元素是不是在这个集合里。但是这个集合本身我们不一定能够保存下来。应该怎么办？

我们用这个哈希函数对D取哈希值，比如说取完之后发现映射到这个地方。应响到一个适零的位置说明什么？说明这个元素一定不在这个集合里。假设取完哈希之后映射过来，映射到这个位置了，说明什么？你说啥也不能说圆，为什么啥也不能说？

如果DD在A还有一些其他元素可能映射到那个地方，也是一可能几不存在。

但是有一个元。

你想说就是哈希碰撞对映射到一个适一的地方，有可能是它确实是集合中的元素，比如说D就等于A所以我们把它找到了。也有可能它不在这个集合里面，但是出现了哈希碰撞，恰好映射到了一个跟集合中某个元素一样的位置。所以用这个blue
filter。我们要注意它有可能出现。Force positive.

但是不会出现force
negative。就是有可能出现误报，但是不会出现漏报。就在里面他一定说在里面，不在里面，它也有可能说在里面，这是布鲁filter的一个基本的工作原理。

布鲁菲特有各种各样的变种，比如说像解决这个哈希碰撞。有的blue
filter的设计用的不是一个哈希函数，而是一组哈希函数。那么每个哈希函数独立的把这个元素映射到这个向量中的某一个位置。用一组哈希函数的好处是如果出现哈希碰撞，那么一般来说不会所有的哈希函数都同时出现碰撞。

我们这里讲的是blue
fil的一个high的工作原理。后面我们会看一下以太坊中的具体代码，看它的里面的blue用filter具体是怎么设计的。回到我们这个例子当中。如果从这个集合中删除一个元素该怎么操作？

该怎么操作？

把相应的位置改成0。

你说的是对的，没法操作。就blue
filter这个数据结构的一个局限性是不支持删除操作。原因就是刚才那个同学说的，比如说你把A这个元素删掉了，这个地方是一，你要不要改？你把它改成零的话，这个集合中有可能有另外一个元素也映射到这个位置，就是哈希碰撞是有可能的。所以这种简单的补充filter是不支持删除操作的。

如果你要支持删除操作的话，这个地方就不能用binmar就，不能是零和一了。你把它改成得是一个计数器，记录这个位置有多少个元素映射过来。而且你还要考虑到这个基础系会不会overflow。这样数据结构就复杂的多了，跟当初设计布鲁filter的初衷是相违背的，所以一般来说bfil是不支持删除操作。大家对这个原理搞明白了吗？

那以太坊中要这个不动filter有什么用呢？

我们说每个交易执行完之后会形成一个收据。这个收据里面就包含了一个om
filter，记录这个交易的类型，然后地址等其他信息发布的区块。在它的块头里也有一个总的filter，这个总的不动filter是这个区块里所有交易的不动filter的一个并集。

所以回到我们刚才那个例子，比如说你要查找过去十天发生的跟这个智能合约相关的所有交易，你怎么找呢？先查一下哪个区块的块头里的blue
filter有我要的这个交易的类型。如果块头你不用filter里没有的话，那么我们就知道这个区块不是我们想要的。如果块头的boom
filter有的话，我们再去查找这个区块里面包含的交易所对应的收据数里面的那些blue
filter，就每个收据的blue
filter看看哪个有，也可能都没有。大家听明白，因为它有可能是force
positive，所以有可能是都没有。如果是有的话，我们再找到相对应的交易，直接进行一下确认。

这个好处是什么？好处是通过这个blue
filter的结构，能够快速过滤掉大量无关的区块。就很多区块你一看块头的不用filter就知道，肯定不会有我们要的交易的。

然后剩下的一些小少数的候选区块，我们再仔细查看。就比如说你是个清洁点，你清洁点的话你只有块头信息。那么根据块头就已经能够过滤掉很多区块，剩下有可能是你想要的那些区块，你再去问全节点要一些进一步的信息。大家有什么问题吗？

基本上，我们就把以太坊中的三棵树给讲完了。这三个树的根其实都是包括在块头里面的。以太坊的运行过程可以把它看作是一个交易驱动的状态机。

这个状态机的状态是什么？就是所有账户的状态，就是状态数中包含的那些内容。那么交易是什么？就是每次发布的区块里包含的那些交易。这些交易通过执行这些交易会驱动系统从当前的状态转移到下一个状态。

比特币呢？比特币你也可以认为是一个交易驱动的状态机，那么比特币中的状态是什么？而ut
x没有被花掉的那些输出。每次新发布一个区块会从uxo里用掉一些输出，又会增加一些新的输出。所以发布这个区块会驱动这个状态机从当前的状态转移到下一个状态。所以ux
o可以认为是比特币状态集中的状态。

而且这两个状态机有一个共同的特点，就是状态转移都得是确定性的对一个给定的当前状态，一个给定的一组给定的交易，就这个区块中包含了这种交易，能够确定性的转移到下一个状态。因为所有的全节点，所有的矿工都要执行同样的状态转移，所以状态转移必须是确定性的。有问题吗？

没有问题。

我来问一个问题。

比如说有人在以太坊上发布一个交易，某个节点收到这个交易。这个交易说转账从A转到B有没有可能这个收款人的地址，这个节点以前从来没听说过。可能吗？你觉得可能的就是以太坊跟比特币是一样的。

创建账户的时候是不需要通知其他人的。只有这个账户第一次收到钱的时候，其他的节点才会知道这个账户的存在。这个时候要在这个状态树中新插入一个节点，因为这是一个新增加的账户。

好，下一个问题稍微难一点。我们前面讲状态数和交易数、收据数的一个区别是，状态数要包含系统中所有账户的状态，无论这些账户是否参与了当前区块中的交易。那么能不能把这个状态数的设计改一下，改成状态数。每个区块的状态数也只包含这个区块中的交易相关的那些账户的状态。

这样就跟交易书和收据书一致了。而且可以大幅度的削减每个区块所对应的状态数的大小，因为大部分的账户状态是不会变的。

这样可以吗？

有谁想说一下？

你觉得可以吗？

你说他肯定是不可以的，要可以的话，维塔里克肯定就这么做。那当然也不一定，已有的系统设计就是最优的。这好几年，如果好的话早就改了，那也许有一个新的加密货币会用这种方法了。

还是在比如。

说他新的交易块里边。

还包括一个新的。

这样会有什么问题呢？

你发一些一致性的问题。

一致性问题你不保存的话，会账户状态不一致，就是你那棵树。

就他这个账户在这个数里放的位置有可能会不一致。对这个状态其他同学有什么想法？

如果这么设计的话，实际上相当于什么？相相当于比特币相当于比特币，比特币是基于交易的账户模型。你这个说的对，就是如果这么设计的话，实际上是个什么结果？就每个区块没有一颗完整的状态树，只有当前这个区块中所包含的交易涉及到的那些账户的状态。

所以这么设计的一个问题是什么？你要想查找某个账户的状态就不方便了。就比如说你有个转账交易，A转给B10个以太币。我们前面讲过要检查什么？A这个账户里是不是真的有十个以太币。那问题是你A这个账户当前区块或最近一个区块了，最近一个区块的对应的状态数可能没有A这个账户，对吧？所以你往前找，往前一直就是找到最近的一个区块，包含这个A账户的最近的一个区块，然后才能知道A的账户余额是多少，对不对？

不方便的地方就在于，如果A这个账户有比较长的一段时间没有发生任何交易。你可能要从后往前扫描很多个区块，才能找到他最近一次的账户状态。还有一个更大的问题是什么？跟上一个问题相关的，为什么要问同学们上一个简单的问题就是你要查找我一个。

比如说我新建一个账户，然后我这个账户我发生了转账，那么新建的账户可能。其他一些节点可能根本就没有保存新建的这个账户。

你实际上想说节点之间状态不一致，那这尤其我不你的思路是对的。但其实不是节点状态不一致的问题，它有一个更严重的问题是什么？我们说A转给B这个钱的时候，你要知道A账户的状态，才能知道A是不是有足够的钱转给B10个亿台币。你也要知道B的账户状态是什么，他当前的余额是多少。因为你要往上面加十个亿台币，对不对？所以你也要找B这个账户的状态，而B这个账户有可能是个新建的账户，这个时候你要找到哪儿去？你要找到创世纪块去，从当天的区块一直扫描到创世纪块，发现B这个账户没有，才知道原来是个新建的账户。大家听明白了吗？这就是这么设计的问题所在。好，我们下面看一下代码中的一些具体的数据结构。

首先我们看一下交易数和收据数的创建过程。在new block
g这个函数里面创建了交易数和收据数，并且得到他们的根细值。我们先看一下交易数的代码，首先判断一下交易列表是否为空。如果是空的话，那么这个区块的块头里的交易数的根哈希值就是一个空的哈希值。否则的话通过调用Dersh这个函数来得到交易数的根哈希值，然后创建这个区块的交易列表。中间这段代码是收据数。首先判断一下收据列表是否为空，如果是空的话，那么块头里收据数的根哈希值就是一个空的哈希值。如果不为空的话，那么也是通过调用der这个函数来得到收据数的根哈希值，然后创建块头里的blue
filter。

我们前面讲过，每个交易执行完后会得到一个收据，所以交易列表的长度跟收据列表的长度应该是一样的。下面这段代码是处理输服区块，我们下节课讲构思协议时会详细讲。这里我们先大概过一下。首先判断一下舒服列表是不是为空，如果是的话，那么块头里输复区块的哈希值就是一个空的哈希值。否则的话通过调用calculate
ancle
hash这个函数计算出哈希值，然后通过一个循环构建出区块里的输复数度。这段代码跟今天课上讲的交易数和收据数没有关系，是我们下节课讲构思协议当中会用到的。

下面我们看一下derive十函数，前面牛block
g函数创建交易数和收据数的时候，调用的都是这个函数。它这里创建的数据结构是一颗串。而try的数据结构是一颗mp
t
portry，大家看明白了吧？以太坊中的三棵树，状态树、交易树、收据树，用的都是MPT。

这是receipt的数据结构。每个交易执行完之后形成一个收据，记录了这个交易的执行结果。这里的bloo域就是这个收据的bloofilter。这个log的意义是个数组，每个收据可以包含多个log，这个收据的blue
filter就是根据这些log产生出来的。

这是我们上节课看过的区块的块头的数据结构里面那个bloo域就是整个区块的bloofilter。它是由我们刚才看到的每个收据的bloom
filter合并在一起得到的。这是我们刚才看过的牛block
g函数红框里的这段代码，就是创建块头里的blue om filter，通过调用create
boom这个函数。这是相关的三个函数的代码事件，create blue log blue和blue
9这3个函数的代码实现。Create
blue函数的参数是这个区块的所有收据这个负循环对每个收据调用logs
b函数来生成这个收据的bfilter，然后把这些bfilter合并起来。用这个or操作合并起来，得到整个区块的blofilter。

Log
b函数的功能是生成每个收据的bfilter，它的参数是这个收据的lo数，我们刚才看过re的数据结构，每个Rept里面包含一个lo的数度。这个函数有两层负循环，外层循环对log数组里的每一个log进行处理。首先把这个log的地址取后加到blofilter里面，这里的b9是blue
filter中用的哈希函数。然后内存循环，把这个logs中包含的每个topic加入到om
fil里，这样就得到了这个收据的布room filter。

布九是布filter中使用的哈希函数，它跟我们课上讲的有一点区别。我们那个粒子中的哈希函数是把集合中的每个元素映射到digest中的某一个位置。我们说这个集合要生成一个digest，那么这个哈希函数就是把每个元素映射到要生成的这个digest中的某一个位置，把这个位置置为一。这里的Blu九函数是把输入映射到bad中的三个位置，也就是说把三个位置都置为一。

我们看一下这个函数的代码，第一行调用crto里面的这个函数生成一个256倍的哈希值。就这里的B在第一行中的B这个变量是个32个字节的哈希值。第二行的R是我们最后要返回的blue
filter，那么我们在这里把它初始化为零，接下来是个循环。把刚才生成的32字节的哈希纸取前六个字节，每两个字节组成一组拼接在一起。然后按得上2047，这个就是按这个位就按的上2047，就相当于是对2048取于得到了一个位于0到2047这个区间里的数。之所以要这样做，是因为以太坊中fil的长度是2048位。这个循环的最后一行把一就这个一左移这么多位，然后合并到上一轮得到的blue
filter里，就通过all运算合并到前面的blue
filter里。这样经过三轮循环，把三个位置置为一后，返回所创建的。

前面讲的是生成bloom filter的过程，那么怎么查询某个bloom
filter里面是否包含了我们感兴趣的topic呢？这是通过调用blue
loolooup函数来实现的，就这个blue loolook
up需要查一下并这个bfilter里有没有包含我们要找的第二个参数这个topic。首先用刚才讲的blue
9函数把这个topic转换成一个bit at vector，然后把它跟这个bom
filter去按的操作，看看得到的结果是不是跟这个bevtor相等。大家注意一下，这个blue
filter里面可能还包含有其他的topic。除了我们要查找的这个topic之外，这个photo里还可以包含其他的talking，这个是正常的。所以要先做一个and然后再跟他自身比较，相当于判断一下我们要查找的这个topic，在bom
filter中对应的位置是不是都是一。这个就是我们这节课要讲的内容。
